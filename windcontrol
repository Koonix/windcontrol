#!/bin/bash
# Ehsan Gh. 2021-05-09
# https://github.com/soystemd

# A fan control script made with simplicity and sucklessness in mind.

# Unlike other fan control programs, this script doesn't change the speed of
# the fans on quick temperature spikes. fans only ramp up (or down)
# if the rise (or fall) of temperature is persistent.

# All configurations should be done by editing and reinstalling the script.


# ================
# = Configuration
# ================

### Configuration
# Temperature sampling interval in seconds:
interval=2
#
# How many intervals should a temperature-rise last to cause a fan rampup:
spike_rejection=4
#
# Fans are set to max pwm at the beginning to start them up if stopped.
# How long (in seconds) to wait for fans to ramp up (start up) at the beginning:
rampup_delay=2 # 0 means no initial rampup.


### Configure temp-pwm pairs
#
# The script checks these temp-pwm pairs from number 1 to the last one,
# and if the current temp is equal or higher than the temp-pwm pair it's checking,
# it will set the fan pwms to the pwms defined in that temp-pwm pair.
#
# however if the current temp is lower, it will check the next ones until a match is found.
#
# so make sure the last temp-pwm is set to a temp that is always lower than
# your cpu temp (eg. 10 degrees)
#
# Note 1: They have to be sorted by temperature, from highest to lowest.
# Note 2: There are 6 of them by default, but you can add as many as you like.

# As a hint, this first temp-pwm pair implies the following:
# If coretemp is 75 degrees celsius or more, set fan pwms to 255 and 255.
coretemp_target[1]=75
pwm_cpu[1]=255
pwm_case[1]=255

coretemp_target[2]=70
pwm_cpu[2]=200
pwm_case[2]=200

coretemp_target[3]=65
pwm_cpu[3]=185
pwm_case[3]=150

coretemp_target[4]=60
pwm_cpu[4]=160
pwm_case[4]=150

coretemp_target[5]=52
pwm_cpu[5]=130
pwm_case[5]=142

coretemp_target[6]=10
pwm_cpu[6]=85
pwm_case[6]=110
### End of temp-pwm pairs


### Kernel file paths;
# Figuring these out shouldn't be too hard.
# You can run the `pwmconfig` command and then
# check the /etc/fancontrol file to figure out these paths.
#
devices_path="/sys/devices/platform"

coretemp_path="${devices_path}/coretemp.0/hwmon/hwmon1"
file_coretemp="${coretemp_path}/temp2_input"

pwm_path="${devices_path}/it87.656/hwmon/hwmon2"
file_pwm_cpu="${pwm_path}/pwm1"
file_pwm_case="${pwm_path}/pwm2"
file_pwm_aux="${pwm_path}/pwm3"

file_pwm_cpu_enable="${pwm_path}/pwm1_enable"
file_pwm_case_enable="${pwm_path}/pwm2_enable"
file_pwm_aux_enable="${pwm_path}/pwm3_enable"
### End of kernel file paths


#################
# Main Function #
#################

# Main function; everything is done here.
main() {
#   Check for possible errors
    error_checks

#   Enable pwm control
    enable_fan_control "$file_pwm_aux_enable"
    enable_fan_control "$file_pwm_cpu_enable"
    enable_fan_control "$file_pwm_case_enable"

#   Ramp up the fans to max for 4 seconds
    initial_rampup


#   Big boy eternal while loop
    while true; do

#       Divide the raw temp sensor's value by 1000 to get temp in celsius.
        coretemp_raw=$(cat "$file_coretemp")
        coretemp_actual=$((coretemp_raw / 1000))

#       Loop over coretemp array to find the one that matches coretemp_actual.
        for (( i=1; i<=${#coretemp_target[@]}; i++ )); do

#           if found the matching target, do the following
            if [[ $coretemp_actual -ge ${coretemp_target[$i]} ]]; then

#                echo "${coretemp_target[$i]}"
#               if the new matching target in this period is different from currently active target, do the following
                if [[ ${coretemp_target[$i]} -ne $current_coretemp_target ]]; then

#                   keep count of how many cycles the increase in temperature been stable for
                    (( coretemp_numberof_periods_that_target_been_different++ ))

#                   if the temperature rise has been stable for long enough, ramp up the fans
                    if [[ $coretemp_numberof_periods_that_target_been_different -ge $spike_rejection ]]; then
                        set_fan_pwm "$file_pwm_cpu" "${pwm_cpu["$i"]}"
                        set_fan_pwm "$file_pwm_case" "${pwm_case["$i"]}"
                        current_coretemp_target="${coretemp_target[$i]}"
                    fi

#               if the temperature rise was just momentary, reset the count and start over
                else
                    coretemp_numberof_periods_that_target_been_different=0
                fi

#               Since the match was found, break out of the for loop.
                break
            fi
        done
        sleep "$interval"
    done
}


#############
# Functions #
#############

# Run some checks and detect errors
error_checks() {
    check_if_already_running
    check_if_all_arrays_same_size
    check_if_pwm_values_in_range "${pwm_case[@]}"
    check_if_pwm_values_in_range "${pwm_cpu[@]}"
    check_if_interval_bigger_than_zero
    check_if_kernel_files_accessible
}


# Ramp up fans at the start for a little while
rampup() {
    set_fan_pwm "$file_pwm_aux" 255
    set_fan_pwm "$file_pwm_cpu" 200
    set_fan_pwm "$file_pwm_case" 250
}


# Rampup and wait a little bit
initial_rampup() {
    [ "$rampup_delay" = 0 ] && return
    rampup
    sleep "$rampup_delay"
}


# Set the given fan to the given pwm
set_fan_pwm() {
    local pwm_file="$1"
    local pwm="$2"
    echo "$pwm" | tee "$pwm_file" > /dev/null 2>&1
}


# Enable fan pwm control
enable_fan_control() {
    local file_pwm_enable="$1"
    echo 1 | tee "$file_pwm_enable" > /dev/null 2>&1
}


# Disable fan pwm control
disable_fan_control() {
    local file_pwm_enable="$1"
    echo 2 | tee "$file_pwm_enable" > /dev/null 2>&1
}


# Check array element count equality
check_if_all_arrays_same_size() {
if [ "${#coretemp_target[@]}" != "${#pwm_cpu[@]}" ] ||\
    [ "${#pwm_cpu[@]}" != "${#pwm_case[@]}" ]
then
    echo "WINDCONTROL ERROR: Imbalance in arrays' element count" >&2 ; exit 1
fi
}


# Check if configured pwm values are between or equal 0 and 255
check_if_pwm_values_in_range() {
    pwm_array=("$@")
    for pwm_value in "${pwm_array[@]}"; do
        if [ "$pwm_value" -gt 255 ] || [ "$pwm_value" -lt 0 ]; then
		    echo "ERROR: PWM Value $pwm_value out of range" >&2 ; exit 1
        fi
    done
}


# Check if interval is greater than 0
check_if_interval_bigger_than_zero() {
	if [ "$interval" -le 0 ]; then
		echo "ERROR: Interval must be at least 1" >&2
		exit 1
	fi
}


# Check if a given file is readable
check_read_access() {
    if [ ! -r "$1" ]; then
		echo "ERROR: Can't access $1" >&2 ; exit 1
    fi
}


# Check if a given file is writable
check_write_access() {
    if [ ! -w "$1" ]; then
		echo "ERROR: Can't access $1" >&2
        echo "Did you sudo?" >&2
        exit 1
    fi
}


# Check if kernel files are accessible
check_if_kernel_files_accessible() {
    check_read_access "$file_coretemp"
    check_write_access "$file_pwm_case"
    check_write_access "$file_pwm_cpu"
    check_write_access "$file_pwm_aux"
}


# Check if windcontrol is already running; if not, make a PID file for it
check_if_already_running() {
    piddir="/var/run"
    pidfile="${piddir}/windcontrol.pid"
    if [ -f "$pidfile" ]; then
	    echo "File $pidfile exists" >&2
	    echo "Windcontrol possibly already running" >&2
    	exit 1
    fi
    check_write_access "$piddir"
    echo $$ > "$pidfile"
}


# Set fans to max upon kill/exit
restore_fans() {
	local status=$1
    echo "Disabling fan control before exiting..."
    rampup
    disable_fan_control "$file_pwm_case_enable"
    disable_fan_control "$file_pwm_aux_enable"
    disable_fan_control "$file_pwm_cpu_enable"
	rm -f "$pidfile"
	exit "$status"
}
# Run the 'restore_fans' functions upon receiving these signals.
trap 'restore_fans 0' SIGQUIT SIGTERM
trap 'restore_fans 1' SIGHUP SIGINT


# Initializing some variables; don't change them
current_coretemp_target="${coretemp_target[1]}"
coretemp_numberof_periods_that_target_been_different=0

# Run the main function
main; exit
